#### 进程，线程，协程

##### 进程

对操作系统来说，进程是分配资源的最小单位。程序启动时，操作系统会给这个程序分配一块内存空间，对于程序本身而言认为它是一块连续的内存空间，称为虚拟内存空间，而实际落实到操作系统内核时通常是一块块的内存碎片。一个进程大小可能是几G,进程之间切换开销比较大，进程可以实现操作系统的并发。

<img src="C:\Users\郑源金\AppData\Roaming\Typora\typora-user-images\image-20230310124534779.png" alt="image-20230310124534779" style="zoom:50%;" />

这片虚拟内存空间，可以划分为内核空间和用户空间，它们相互隔离，程序即使崩溃了，内核空间也不会受到影响。进程运行在内核空间时称为内核态，运行在用户空间称之为用户态。内核空间用于执行内核代码，用户空间只用于执行用户程序，若要执行各种IO操作，就需要通过系统调用等方式从用户态切换到内核态进入内核空间进行操作。

**多进程并发有两个缺点**：一是内核的管理成本高，二是无法简单通过内存同步数据，进程间通信较困难。因此，多线程模式出现了。

#### 线程

对操作系统来说，**线程是资源调度的最小单位**，线程是进程的一个执行单元，一个进程至少需要包含一个线程（可以包含多个），只有拥有了线程的进程才会被CPU执行。一个线程大小约是几M。线程可以实现进程内部的并发。总结起来就是：**进程主要面向内存的分配管理，线程主要面向CPU的调度。**

<img src="C:\Users\郑源金\AppData\Roaming\Typora\typora-user-images\image-20230310124711459.png" alt="image-20230310124711459" style="zoom:33%;" />

一个进程下的多个线程是共享这个进程的内存空间的，即线程没有自己独立的内存空间。正因如此，所以一个线程可以读、写甚至清除另一个线程的堆栈。相当于线程之间是没有保护的。但每个线程都有自己的堆栈、程序计数器、寄存器等信息，这些都不是共享的。线程也被称为轻量级进程，与进程调度类似，CPU在线程之间快速切换，就有了线程并行运行的假象。线程间的切换开销要比进程间切换小的多，因为不需要切换页表，虚拟地址空间等等一些东西。
共享地址空间可以方便的共享对象，但也有一个问题，就是任何一个线程崩溃，进程中所有线程会一起崩溃。

同时，多线程虽然进一步提高了并发，但在当今互联网高并发场景下，为每个任务都创建一个线程甚至是创建上万个线程来工作是不现实的，因为会消耗大量的内存，而且多线程开发要考虑很多同步竞争等问题，如锁、竞争冲突等。此外，不管是进程还是线程，它们的切换都是由内核控制的，所以线程的切换涉及到用户空间和内核空间的切换（特权模式的切换），然后需要操作系统的调度模块完成线程调度。

#### 协程

高并发的情况如何更好的提高CPU的利用率呢？于是协程就出现了。如一个进程可包含多个线程，一个线程也可以包含多个协程。一个协程的大小约是几KB。

<img src="C:\Users\郑源金\AppData\Roaming\Typora\typora-user-images\image-20230310125119901.png" alt="image-20230310125119901" style="zoom:50%;" />

线程可以分为 “内核态 “线程和” 用户态 “线程。一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”。

<img src="C:\Users\郑源金\AppData\Roaming\Typora\typora-user-images\image-20230310125151621.png" alt="image-20230310125151621" style="zoom:50%;" />

然后再细化分类一下，内核线程还叫 “线程 (thread)”，**用户线程叫 “协程** (co-routine)”。

<img src="C:\Users\郑源金\AppData\Roaming\Typora\typora-user-images\image-20230310125230822.png" alt="image-20230310125230822" style="zoom:50%;" />

协程它不像线程和进程那样需要进行系统内核上的上下文切换（协程切换不涉及特权模式的切换），协程切换只涉及基本的CPU上下文切换，完全在用户空间完成，做的事要比进程线程少，因此切换开销要更小。

协程的优点：一是可以提高CPU利用率，避免系统内核级的线程间频繁切换造成的资源浪费；二是可以节约内存，一个进程几G、一个线程几M、一个协程几KB；三是稳定性好一些，线程可以通过内存共享数据，但是一个线程挂了，进程中所有线程会一起崩溃。

协程缺点：**协程本质是个单线程**，它不能同时使用单个 CPU 的多个核；一旦协程出现阻塞，将会阻塞整个线程


#### Goroutine

goroutine 是 Golang 并发的核心。一个 goroutine 本质上是一个协程（其与协程的具体区别下面介绍），Go 内部帮你实现了 goroutine 之间的内存共享。执行 goroutine 只需极少的栈内存(大概4~5KB，也可按需增大和缩小)。正因如此，golang 中同时运行成千上万个并发任务也是可以的。



#### Golang的GMP原理

GMP都代表什么意思

G - goroutine协程

M- thread线程

P - processor处理器 ：处理器包含了运行goroutine的资源，如果thread想运行goroutine，必须先获取processor,同时，processor还包含了可运行的G队列。

##### GMP模型

golang 中线程是运行 goroutine 的实体，调度器的作用是把可运行的 goroutine 分配到工作线程上。

<img src="C:\Users\郑源金\AppData\Roaming\Typora\typora-user-images\image-20230310125952502.png" alt="image-20230310125952502" style="zoom:50%;" />

- 全局队列：存放等待运行的 G。

- P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量不超过 256 个。新建 G’ 时，G’ 优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移到全局队列。
- P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。
- M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。
- Goroutine 的调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行。

**P 和 M 的个数问题？**

1. P 的数量：
   由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行

2.M 的数量：
go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000。一般内核很难支持这么多线程数，这个限制可以忽略。
runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量一个 M 阻塞了，会创建新的 M

**M 与 P 的数量没有绝对关系**，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。

##### P 和 M 何时会被创建？

P 何时创建：在确定了 P 的最大数量 N 后，程序运行时系统会创建 N 个 P。

M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞了，但是 P 中还有很多就绪任务，就要去寻找空闲 M，没找到空闲的 M 就会去创建新的 M。


##### 调度器的设计策略

复用线程：避免线程被频繁创建、销毁。

1）work stealing 机制
当本线程无可运行的 G 时，会尝试从其他线程绑定的 P 偷取 G，而不是把线程销毁。

2）hand off 机制
当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。



**利用并行**：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。

**抢占**：Golang 中，为防止其他 goroutine 被饿死，一个 goroutine 最多占用 CPU 10ms（抢占）

全局 G 队列：当 M 执行 work stealing 从其他 P 偷不到 G 时，就可以从全局 G 队列获取 G。
